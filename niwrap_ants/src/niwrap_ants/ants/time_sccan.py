# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

TIME_SCCAN_METADATA = Metadata(
    id="df24e51b7f0bd36e46f31654254028b83351eca4.boutiques",
    name="TimeSCCAN",
    package="ants",
    container_image_tag="antsx/ants:v2.5.3",
)


TimeSccanTimeseriesimageToMatrixParameters = typing.TypedDict('TimeSccanTimeseriesimageToMatrixParameters', {
    "@type": typing.NotRequired[typing.Literal["timeseriesimage_to_matrix"]],
    "timeseries_image": InputPathType,
    "mask_image": InputPathType,
})
TimeSccanTimeseriesimageToMatrixParametersTagged = typing.TypedDict('TimeSccanTimeseriesimageToMatrixParametersTagged', {
    "@type": typing.Literal["timeseriesimage_to_matrix"],
    "timeseries_image": InputPathType,
    "mask_image": InputPathType,
})


TimeSccanNetworkSccaParameters = typing.TypedDict('TimeSccanNetworkSccaParameters', {
    "@type": typing.NotRequired[typing.Literal["network_scca"]],
    "time_matrix": InputPathType,
    "label_matrix": InputPathType,
})
TimeSccanNetworkSccaParametersTagged = typing.TypedDict('TimeSccanNetworkSccaParametersTagged', {
    "@type": typing.Literal["network_scca"],
    "time_matrix": InputPathType,
    "label_matrix": InputPathType,
})


TimeSccanNetworkRegionAveragingParameters = typing.TypedDict('TimeSccanNetworkRegionAveragingParameters', {
    "@type": typing.NotRequired[typing.Literal["network_region_averaging"]],
    "time_matrix": InputPathType,
    "label_matrix": InputPathType,
})
TimeSccanNetworkRegionAveragingParametersTagged = typing.TypedDict('TimeSccanNetworkRegionAveragingParametersTagged', {
    "@type": typing.Literal["network_region_averaging"],
    "time_matrix": InputPathType,
    "label_matrix": InputPathType,
})


TimeSccanParameters = typing.TypedDict('TimeSccanParameters', {
    "@type": typing.NotRequired[typing.Literal["ants/TimeSCCAN"]],
    "output": str,
    "number_consecutive_labels": typing.NotRequired[int | None],
    "minimum_region_size": typing.NotRequired[int | None],
    "iterations": typing.NotRequired[int | None],
    "sparsity": typing.NotRequired[float | None],
    "n_eigenvectors": typing.NotRequired[int | None],
    "robustify": typing.NotRequired[int | None],
    "l1": typing.NotRequired[float | None],
    "cluster_thresh": typing.NotRequired[int | None],
    "ridge_cca": typing.NotRequired[int | None],
    "partial_scca_option": typing.NotRequired[typing.Literal["PQ", "PminusRQ", "PQminusR", "PminusRQminusR"] | None],
    "timeseriesimage_to_matrix": typing.NotRequired[TimeSccanTimeseriesimageToMatrixParameters | None],
    "labelsimage_to_matrix": typing.NotRequired[InputPathType | None],
    "network": typing.NotRequired[typing.Union[TimeSccanNetworkSccaParametersTagged, TimeSccanNetworkRegionAveragingParametersTagged] | None],
})
TimeSccanParametersTagged = typing.TypedDict('TimeSccanParametersTagged', {
    "@type": typing.Literal["ants/TimeSCCAN"],
    "output": str,
    "number_consecutive_labels": typing.NotRequired[int | None],
    "minimum_region_size": typing.NotRequired[int | None],
    "iterations": typing.NotRequired[int | None],
    "sparsity": typing.NotRequired[float | None],
    "n_eigenvectors": typing.NotRequired[int | None],
    "robustify": typing.NotRequired[int | None],
    "l1": typing.NotRequired[float | None],
    "cluster_thresh": typing.NotRequired[int | None],
    "ridge_cca": typing.NotRequired[int | None],
    "partial_scca_option": typing.NotRequired[typing.Literal["PQ", "PminusRQ", "PQminusR", "PminusRQminusR"] | None],
    "timeseriesimage_to_matrix": typing.NotRequired[TimeSccanTimeseriesimageToMatrixParameters | None],
    "labelsimage_to_matrix": typing.NotRequired[InputPathType | None],
    "network": typing.NotRequired[typing.Union[TimeSccanNetworkSccaParametersTagged, TimeSccanNetworkRegionAveragingParametersTagged] | None],
})


def time_sccan_network_cargs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build cargs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build cargs function.
    """
    return {
        "network_scca": time_sccan_network_scca_cargs,
        "network_region_averaging": time_sccan_network_region_averaging_cargs,
    }.get(t)


def time_sccan_network_outputs_dyn_fn(
    t: str,
) -> typing.Any:
    """
    Get build outputs function by command type.
    
    Args:
        t: Command type.
    Returns:
        Build outputs function.
    """
    return {
    }.get(t)


def time_sccan_timeseriesimage_to_matrix_params(
    timeseries_image: InputPathType,
    mask_image: InputPathType,
) -> TimeSccanTimeseriesimageToMatrixParametersTagged:
    """
    Build parameters.
    
    Args:
        timeseries_image:.
        mask_image:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "timeseriesimage_to_matrix",
        "timeseries_image": timeseries_image,
        "mask_image": mask_image,
    }
    return params


def time_sccan_timeseriesimage_to_matrix_cargs(
    params: TimeSccanTimeseriesimageToMatrixParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append(execution.input_file(params.get("timeseries_image", None)) + execution.input_file(params.get("mask_image", None)))
    return cargs


def time_sccan_network_scca_params(
    time_matrix: InputPathType,
    label_matrix: InputPathType,
) -> TimeSccanNetworkSccaParametersTagged:
    """
    Build parameters.
    
    Args:
        time_matrix:.
        label_matrix:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "network_scca",
        "time_matrix": time_matrix,
        "label_matrix": label_matrix,
    }
    return params


def time_sccan_network_scca_cargs(
    params: TimeSccanNetworkSccaParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("scca[" + execution.input_file(params.get("time_matrix", None)) + "," + execution.input_file(params.get("label_matrix", None)) + "]")
    return cargs


def time_sccan_network_region_averaging_params(
    time_matrix: InputPathType,
    label_matrix: InputPathType,
) -> TimeSccanNetworkRegionAveragingParametersTagged:
    """
    Build parameters.
    
    Args:
        time_matrix:.
        label_matrix:.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "network_region_averaging",
        "time_matrix": time_matrix,
        "label_matrix": label_matrix,
    }
    return params


def time_sccan_network_region_averaging_cargs(
    params: TimeSccanNetworkRegionAveragingParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("region-averaging[" + execution.input_file(params.get("time_matrix", None)) + "," + execution.input_file(params.get("label_matrix", None)) + "]")
    return cargs


class TimeSccanOutputs(typing.NamedTuple):
    """
    Output object returned when calling `TimeSccanParameters(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    correlation_matrix: OutputPathType
    """The output is the 2D correlation matrix."""


def time_sccan_params(
    output: str,
    number_consecutive_labels: int | None = None,
    minimum_region_size: int | None = None,
    iterations: int | None = None,
    sparsity: float | None = None,
    n_eigenvectors: int | None = None,
    robustify: int | None = None,
    l1: float | None = None,
    cluster_thresh: int | None = None,
    ridge_cca: int | None = None,
    partial_scca_option: typing.Literal["PQ", "PminusRQ", "PQminusR", "PminusRQminusR"] | None = None,
    timeseriesimage_to_matrix: TimeSccanTimeseriesimageToMatrixParameters | None = None,
    labelsimage_to_matrix: InputPathType | None = None,
    network: typing.Union[TimeSccanNetworkSccaParametersTagged, TimeSccanNetworkRegionAveragingParametersTagged] | None = None,
) -> TimeSccanParametersTagged:
    """
    Build parameters.
    
    Args:
        output: Output is a 2D correlation matrix.
        number_consecutive_labels: Number of consecutive labels in data.
        minimum_region_size: Minimum size of a region: regions below this size\
            are given a 0.0 connectivity value.
        iterations: Number of iterations.
        sparsity: Sparsity - a float from (0,1] indicating what fraction of the\
            data to use.
        n_eigenvectors: Number of permutations to use in scca.
        robustify: Rank-based scca.
        l1: Use l1 ( > 0 ) or l0 ( < 0 ) penalty, also sets gradient step size\
            e.g. -l 0.5 ( L1 ) , -l -0.5 (L0) will set 0.5 grad descent step for\
            either penalty.
        cluster_thresh: Cluster threshold on view P.
        ridge_cca: Number of permutations to use in scca.
        partial_scca_option: Choices for partial SCCA: PQ, PminusRQ, PQminusR,\
            PminusRQminusR.
        timeseriesimage_to_matrix: Takes a timeseries (4D) image and converts\
            it to a 2D matrix csv format as output. If the mask has multiple labels\
            (more than one), then the average time series in each label will be\
            computed and put in the csv.
        labelsimage_to_matrix: Takes a labeled (3D) image and converts it to a\
            2D matrix csv format as output.
        network: Build the network connectivity matrix.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "ants/TimeSCCAN",
        "output": output,
    }
    if number_consecutive_labels is not None:
        params["number_consecutive_labels"] = number_consecutive_labels
    if minimum_region_size is not None:
        params["minimum_region_size"] = minimum_region_size
    if iterations is not None:
        params["iterations"] = iterations
    if sparsity is not None:
        params["sparsity"] = sparsity
    if n_eigenvectors is not None:
        params["n_eigenvectors"] = n_eigenvectors
    if robustify is not None:
        params["robustify"] = robustify
    if l1 is not None:
        params["l1"] = l1
    if cluster_thresh is not None:
        params["cluster_thresh"] = cluster_thresh
    if ridge_cca is not None:
        params["ridge_cca"] = ridge_cca
    if partial_scca_option is not None:
        params["partial_scca_option"] = partial_scca_option
    if timeseriesimage_to_matrix is not None:
        params["timeseriesimage_to_matrix"] = timeseriesimage_to_matrix
    if labelsimage_to_matrix is not None:
        params["labelsimage_to_matrix"] = labelsimage_to_matrix
    if network is not None:
        params["network"] = network
    return params


def time_sccan_cargs(
    params: TimeSccanParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("TimeSCCAN")
    cargs.extend([
        "--output",
        params.get("output", None)
    ])
    if params.get("number_consecutive_labels", None) is not None:
        cargs.extend([
            "-l",
            str(params.get("number_consecutive_labels", None))
        ])
    if params.get("minimum_region_size", None) is not None:
        cargs.extend([
            "-R",
            str(params.get("minimum_region_size", None))
        ])
    if params.get("iterations", None) is not None:
        cargs.extend([
            "-i",
            str(params.get("iterations", None))
        ])
    if params.get("sparsity", None) is not None:
        cargs.extend([
            "-s",
            str(params.get("sparsity", None))
        ])
    if params.get("n_eigenvectors", None) is not None:
        cargs.extend([
            "-n",
            str(params.get("n_eigenvectors", None))
        ])
    if params.get("robustify", None) is not None:
        cargs.extend([
            "-r",
            str(params.get("robustify", None))
        ])
    if params.get("l1", None) is not None:
        cargs.extend([
            "-l",
            str(params.get("l1", None))
        ])
    if params.get("cluster_thresh", None) is not None:
        cargs.extend([
            "--ClusterThresh",
            str(params.get("cluster_thresh", None))
        ])
    if params.get("ridge_cca", None) is not None:
        cargs.extend([
            "-e",
            str(params.get("ridge_cca", None))
        ])
    if params.get("partial_scca_option", None) is not None:
        cargs.extend([
            "--partial-scca-option",
            params.get("partial_scca_option", None)
        ])
    if params.get("timeseriesimage_to_matrix", None) is not None:
        cargs.extend([
            "--timeseriesimage-to-matrix",
            *time_sccan_timeseriesimage_to_matrix_cargs(params.get("timeseriesimage_to_matrix", None), execution)
        ])
    if params.get("labelsimage_to_matrix", None) is not None:
        cargs.extend([
            "--labelsimage-to-matrix",
            execution.input_file(params.get("labelsimage_to_matrix", None))
        ])
    if params.get("network", None) is not None:
        cargs.extend([
            "--network",
            *time_sccan_network_cargs_dyn_fn(params.get("network", None)["@type"])(params.get("network", None), execution)
        ])
    return cargs


def time_sccan_outputs(
    params: TimeSccanParameters,
    execution: Execution,
) -> TimeSccanOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = TimeSccanOutputs(
        root=execution.output_file("."),
        correlation_matrix=execution.output_file(params.get("output", None)),
    )
    return ret


def time_sccan_execute(
    params: TimeSccanParameters,
    runner: Runner | None = None,
) -> TimeSccanOutputs:
    """
    TimeSCCAN
    
    A tool for sparse statistical analysis on connectivity within a subject.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TimeSccanOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(TIME_SCCAN_METADATA)
    params = execution.params(params)
    cargs = time_sccan_cargs(params, execution)
    ret = time_sccan_outputs(params, execution)
    execution.run(cargs)
    return ret


def time_sccan(
    output: str,
    number_consecutive_labels: int | None = None,
    minimum_region_size: int | None = None,
    iterations: int | None = None,
    sparsity: float | None = None,
    n_eigenvectors: int | None = None,
    robustify: int | None = None,
    l1: float | None = None,
    cluster_thresh: int | None = None,
    ridge_cca: int | None = None,
    partial_scca_option: typing.Literal["PQ", "PminusRQ", "PQminusR", "PminusRQminusR"] | None = None,
    timeseriesimage_to_matrix: TimeSccanTimeseriesimageToMatrixParameters | None = None,
    labelsimage_to_matrix: InputPathType | None = None,
    network: typing.Union[TimeSccanNetworkSccaParametersTagged, TimeSccanNetworkRegionAveragingParametersTagged] | None = None,
    runner: Runner | None = None,
) -> TimeSccanOutputs:
    """
    TimeSCCAN
    
    A tool for sparse statistical analysis on connectivity within a subject.
    
    Author: ANTs Developers
    
    URL: https://github.com/ANTsX/ANTs
    
    Args:
        output: Output is a 2D correlation matrix.
        number_consecutive_labels: Number of consecutive labels in data.
        minimum_region_size: Minimum size of a region: regions below this size\
            are given a 0.0 connectivity value.
        iterations: Number of iterations.
        sparsity: Sparsity - a float from (0,1] indicating what fraction of the\
            data to use.
        n_eigenvectors: Number of permutations to use in scca.
        robustify: Rank-based scca.
        l1: Use l1 ( > 0 ) or l0 ( < 0 ) penalty, also sets gradient step size\
            e.g. -l 0.5 ( L1 ) , -l -0.5 (L0) will set 0.5 grad descent step for\
            either penalty.
        cluster_thresh: Cluster threshold on view P.
        ridge_cca: Number of permutations to use in scca.
        partial_scca_option: Choices for partial SCCA: PQ, PminusRQ, PQminusR,\
            PminusRQminusR.
        timeseriesimage_to_matrix: Takes a timeseries (4D) image and converts\
            it to a 2D matrix csv format as output. If the mask has multiple labels\
            (more than one), then the average time series in each label will be\
            computed and put in the csv.
        labelsimage_to_matrix: Takes a labeled (3D) image and converts it to a\
            2D matrix csv format as output.
        network: Build the network connectivity matrix.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `TimeSccanOutputs`).
    """
    params = time_sccan_params(
        output=output,
        number_consecutive_labels=number_consecutive_labels,
        minimum_region_size=minimum_region_size,
        iterations=iterations,
        sparsity=sparsity,
        n_eigenvectors=n_eigenvectors,
        robustify=robustify,
        l1=l1,
        cluster_thresh=cluster_thresh,
        ridge_cca=ridge_cca,
        partial_scca_option=partial_scca_option,
        timeseriesimage_to_matrix=timeseriesimage_to_matrix,
        labelsimage_to_matrix=labelsimage_to_matrix,
        network=network,
    )
    return time_sccan_execute(params, runner)


__all__ = [
    "TIME_SCCAN_METADATA",
    "TimeSccanOutputs",
    "time_sccan",
    "time_sccan_execute",
    "time_sccan_network_region_averaging_params",
    "time_sccan_network_scca_params",
    "time_sccan_params",
    "time_sccan_timeseriesimage_to_matrix_params",
]
