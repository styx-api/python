# This file was auto generated by Styx.
# Do not edit this file directly.

import typing
import pathlib
from styxdefs import *

FLIRT_METADATA = Metadata(
    id="c1e04fa70c0e223bd30966b0bf0fa3ed5c379486.boutiques",
    name="flirt",
    package="fsl",
    container_image_tag="brainlife/fsl:6.0.4-patched2",
)


FlirtParameters = typing.TypedDict('FlirtParameters', {
    "@type": typing.NotRequired[typing.Literal["fsl/flirt"]],
    "in_file": InputPathType,
    "reference": InputPathType,
    "out_file": str,
    "out_matrix_file": str,
    "angle_rep": typing.NotRequired[typing.Literal["quaternion", "euler"] | None],
    "apply_isoxfm": typing.NotRequired[float | None],
    "apply_xfm": bool,
    "bbrslope": typing.NotRequired[float | None],
    "bbrtype": typing.NotRequired[typing.Literal["signed", "global_abs", "local_abs"] | None],
    "bgvalue": typing.NotRequired[float | None],
    "bins": typing.NotRequired[int | None],
    "coarse_search": typing.NotRequired[int | None],
    "cost": typing.NotRequired[typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None],
    "cost_func": typing.NotRequired[typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None],
    "datatype": typing.NotRequired[typing.Literal["char", "short", "int", "float", "double"] | None],
    "display_init": bool,
    "dof": typing.NotRequired[int | None],
    "echospacing": typing.NotRequired[float | None],
    "fieldmap": typing.NotRequired[InputPathType | None],
    "fieldmapmask": typing.NotRequired[InputPathType | None],
    "fine_search": typing.NotRequired[int | None],
    "force_scaling": bool,
    "in_matrix_file": typing.NotRequired[InputPathType | None],
    "in_weight": typing.NotRequired[InputPathType | None],
    "interp": typing.NotRequired[typing.Literal["trilinear", "nearestneighbour", "sinc", "spline"] | None],
    "min_sampling": typing.NotRequired[float | None],
    "no_clamp": bool,
    "no_resample": bool,
    "no_resample_blur": bool,
    "no_search": bool,
    "padding_size": typing.NotRequired[int | None],
    "pedir": typing.NotRequired[int | None],
    "ref_weight": typing.NotRequired[InputPathType | None],
    "rigid2D": bool,
    "schedule": typing.NotRequired[InputPathType | None],
    "searchr_x": typing.NotRequired[list[int] | None],
    "searchr_y": typing.NotRequired[list[int] | None],
    "searchr_z": typing.NotRequired[list[int] | None],
    "sinc_width": typing.NotRequired[int | None],
    "sinc_window": typing.NotRequired[typing.Literal["rectangular", "hanning", "blackman"] | None],
    "uses_qform": bool,
    "verbose": typing.NotRequired[int | None],
    "wm_seg": typing.NotRequired[InputPathType | None],
    "wmcoords": typing.NotRequired[InputPathType | None],
    "wmnorms": typing.NotRequired[InputPathType | None],
})
FlirtParametersTagged = typing.TypedDict('FlirtParametersTagged', {
    "@type": typing.Literal["fsl/flirt"],
    "in_file": InputPathType,
    "reference": InputPathType,
    "out_file": str,
    "out_matrix_file": str,
    "angle_rep": typing.NotRequired[typing.Literal["quaternion", "euler"] | None],
    "apply_isoxfm": typing.NotRequired[float | None],
    "apply_xfm": bool,
    "bbrslope": typing.NotRequired[float | None],
    "bbrtype": typing.NotRequired[typing.Literal["signed", "global_abs", "local_abs"] | None],
    "bgvalue": typing.NotRequired[float | None],
    "bins": typing.NotRequired[int | None],
    "coarse_search": typing.NotRequired[int | None],
    "cost": typing.NotRequired[typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None],
    "cost_func": typing.NotRequired[typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None],
    "datatype": typing.NotRequired[typing.Literal["char", "short", "int", "float", "double"] | None],
    "display_init": bool,
    "dof": typing.NotRequired[int | None],
    "echospacing": typing.NotRequired[float | None],
    "fieldmap": typing.NotRequired[InputPathType | None],
    "fieldmapmask": typing.NotRequired[InputPathType | None],
    "fine_search": typing.NotRequired[int | None],
    "force_scaling": bool,
    "in_matrix_file": typing.NotRequired[InputPathType | None],
    "in_weight": typing.NotRequired[InputPathType | None],
    "interp": typing.NotRequired[typing.Literal["trilinear", "nearestneighbour", "sinc", "spline"] | None],
    "min_sampling": typing.NotRequired[float | None],
    "no_clamp": bool,
    "no_resample": bool,
    "no_resample_blur": bool,
    "no_search": bool,
    "padding_size": typing.NotRequired[int | None],
    "pedir": typing.NotRequired[int | None],
    "ref_weight": typing.NotRequired[InputPathType | None],
    "rigid2D": bool,
    "schedule": typing.NotRequired[InputPathType | None],
    "searchr_x": typing.NotRequired[list[int] | None],
    "searchr_y": typing.NotRequired[list[int] | None],
    "searchr_z": typing.NotRequired[list[int] | None],
    "sinc_width": typing.NotRequired[int | None],
    "sinc_window": typing.NotRequired[typing.Literal["rectangular", "hanning", "blackman"] | None],
    "uses_qform": bool,
    "verbose": typing.NotRequired[int | None],
    "wm_seg": typing.NotRequired[InputPathType | None],
    "wmcoords": typing.NotRequired[InputPathType | None],
    "wmnorms": typing.NotRequired[InputPathType | None],
})


class FlirtOutputs(typing.NamedTuple):
    """
    Output object returned when calling `FlirtParameters(...)`.
    """
    root: OutputPathType
    """Output root folder. This is the root folder for all outputs."""
    out_file: OutputPathType
    """Registered output file."""
    out_matrix_file: OutputPathType
    """Output affine matrix in 4x4 asciii format."""


def flirt_params(
    in_file: InputPathType,
    reference: InputPathType,
    out_file: str,
    out_matrix_file: str,
    angle_rep: typing.Literal["quaternion", "euler"] | None = None,
    apply_isoxfm: float | None = None,
    apply_xfm: bool = False,
    bbrslope: float | None = None,
    bbrtype: typing.Literal["signed", "global_abs", "local_abs"] | None = None,
    bgvalue: float | None = None,
    bins: int | None = None,
    coarse_search: int | None = None,
    cost: typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None = None,
    cost_func: typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None = None,
    datatype: typing.Literal["char", "short", "int", "float", "double"] | None = None,
    display_init: bool = False,
    dof: int | None = None,
    echospacing: float | None = None,
    fieldmap: InputPathType | None = None,
    fieldmapmask: InputPathType | None = None,
    fine_search: int | None = None,
    force_scaling: bool = False,
    in_matrix_file: InputPathType | None = None,
    in_weight: InputPathType | None = None,
    interp: typing.Literal["trilinear", "nearestneighbour", "sinc", "spline"] | None = None,
    min_sampling: float | None = None,
    no_clamp: bool = False,
    no_resample: bool = False,
    no_resample_blur: bool = False,
    no_search: bool = False,
    padding_size: int | None = None,
    pedir: int | None = None,
    ref_weight: InputPathType | None = None,
    rigid2_d: bool = False,
    schedule: InputPathType | None = None,
    searchr_x: list[int] | None = None,
    searchr_y: list[int] | None = None,
    searchr_z: list[int] | None = None,
    sinc_width: int | None = None,
    sinc_window: typing.Literal["rectangular", "hanning", "blackman"] | None = None,
    uses_qform: bool = False,
    verbose: int | None = None,
    wm_seg: InputPathType | None = None,
    wmcoords: InputPathType | None = None,
    wmnorms: InputPathType | None = None,
) -> FlirtParametersTagged:
    """
    Build parameters.
    
    Args:
        in_file: Input file.
        reference: Reference file.
        out_file: Registered output file.
        out_matrix_file: Output affine matrix in 4x4 asciii format.
        angle_rep: 'quaternion' or 'euler'. Representation of rotation angles.
        apply_isoxfm: As applyxfm but forces isotropic resampling.
        apply_xfm: Apply transformation supplied by in_matrix_file or\
            uses_qform to use the affine matrix stored in the reference header.
        bbrslope: Value of bbr slope.
        bbrtype: 'signed' or 'global_abs' or 'local_abs'. Type of bbr cost\
            function: signed [default], global_abs, local_abs.
        bgvalue: Use specified background value for points outside fov.
        bins: Number of histogram bins.
        coarse_search: Coarse search delta angle.
        cost: 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or 'leastsq'\
            or 'labeldiff' or 'bbr'. Cost function.
        cost_func: 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or\
            'leastsq' or 'labeldiff' or 'bbr'. Cost function.
        datatype: 'char' or 'short' or 'int' or 'float' or 'double'. Force\
            output data type.
        display_init: Display initial matrix.
        dof: Number of transform degrees of freedom.
        echospacing: Value of epi echo spacing - units of seconds.
        fieldmap: Fieldmap image in rads/s - must be already registered to the\
            reference image.
        fieldmapmask: Mask for fieldmap image.
        fine_search: Fine search delta angle.
        force_scaling: Force rescaling even for low-res images.
        in_matrix_file: Input 4x4 affine matrix.
        in_weight: File for input weighting volume.
        interp: 'trilinear' or 'nearestneighbour' or 'sinc' or 'spline'. Final\
            interpolation method used in reslicing.
        min_sampling: Set minimum voxel dimension for sampling.
        no_clamp: Do not use intensity clamping.
        no_resample: Do not change input sampling.
        no_resample_blur: Do not use blurring on downsampling.
        no_search: Set all angular searches to ranges 0 to 0.
        padding_size: For applyxfm: interpolates outside image by size.
        pedir: Phase encode direction of epi - 1/2/3=x/y/z & -1/-2/-3=-x/-y/-z.
        ref_weight: File for reference weighting volume.
        rigid2_d: Use 2d rigid body mode - ignores dof.
        schedule: Replaces default schedule.
        searchr_x: Search angles along x-axis, in degrees.
        searchr_y: Search angles along y-axis, in degrees.
        searchr_z: Search angles along z-axis, in degrees.
        sinc_width: Full-width in voxels.
        sinc_window: 'rectangular' or 'hanning' or 'blackman'. Sinc window.
        uses_qform: Initialize using sform or qform.
        verbose: Verbose mode, 0 is least.
        wm_seg: White matter segmentation volume needed by bbr cost function.
        wmcoords: White matter boundary coordinates for bbr cost function.
        wmnorms: White matter boundary normals for bbr cost function.
    Returns:
        Parameter dictionary
    """
    params = {
        "@type": "fsl/flirt",
        "in_file": in_file,
        "reference": reference,
        "out_file": out_file,
        "out_matrix_file": out_matrix_file,
        "apply_xfm": apply_xfm,
        "display_init": display_init,
        "force_scaling": force_scaling,
        "no_clamp": no_clamp,
        "no_resample": no_resample,
        "no_resample_blur": no_resample_blur,
        "no_search": no_search,
        "rigid2D": rigid2_d,
        "uses_qform": uses_qform,
    }
    if angle_rep is not None:
        params["angle_rep"] = angle_rep
    if apply_isoxfm is not None:
        params["apply_isoxfm"] = apply_isoxfm
    if bbrslope is not None:
        params["bbrslope"] = bbrslope
    if bbrtype is not None:
        params["bbrtype"] = bbrtype
    if bgvalue is not None:
        params["bgvalue"] = bgvalue
    if bins is not None:
        params["bins"] = bins
    if coarse_search is not None:
        params["coarse_search"] = coarse_search
    if cost is not None:
        params["cost"] = cost
    if cost_func is not None:
        params["cost_func"] = cost_func
    if datatype is not None:
        params["datatype"] = datatype
    if dof is not None:
        params["dof"] = dof
    if echospacing is not None:
        params["echospacing"] = echospacing
    if fieldmap is not None:
        params["fieldmap"] = fieldmap
    if fieldmapmask is not None:
        params["fieldmapmask"] = fieldmapmask
    if fine_search is not None:
        params["fine_search"] = fine_search
    if in_matrix_file is not None:
        params["in_matrix_file"] = in_matrix_file
    if in_weight is not None:
        params["in_weight"] = in_weight
    if interp is not None:
        params["interp"] = interp
    if min_sampling is not None:
        params["min_sampling"] = min_sampling
    if padding_size is not None:
        params["padding_size"] = padding_size
    if pedir is not None:
        params["pedir"] = pedir
    if ref_weight is not None:
        params["ref_weight"] = ref_weight
    if schedule is not None:
        params["schedule"] = schedule
    if searchr_x is not None:
        params["searchr_x"] = searchr_x
    if searchr_y is not None:
        params["searchr_y"] = searchr_y
    if searchr_z is not None:
        params["searchr_z"] = searchr_z
    if sinc_width is not None:
        params["sinc_width"] = sinc_width
    if sinc_window is not None:
        params["sinc_window"] = sinc_window
    if verbose is not None:
        params["verbose"] = verbose
    if wm_seg is not None:
        params["wm_seg"] = wm_seg
    if wmcoords is not None:
        params["wmcoords"] = wmcoords
    if wmnorms is not None:
        params["wmnorms"] = wmnorms
    return params


def flirt_cargs(
    params: FlirtParameters,
    execution: Execution,
) -> list[str]:
    """
    Build command-line arguments from parameters.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Command-line arguments.
    """
    cargs = []
    cargs.append("flirt")
    cargs.extend([
        "-in",
        execution.input_file(params.get("in_file", None))
    ])
    cargs.extend([
        "-ref",
        execution.input_file(params.get("reference", None))
    ])
    cargs.extend([
        "-out",
        params.get("out_file", None)
    ])
    cargs.extend([
        "-omat",
        params.get("out_matrix_file", None)
    ])
    if params.get("angle_rep", None) is not None:
        cargs.extend([
            "-anglerep",
            params.get("angle_rep", None)
        ])
    if params.get("apply_isoxfm", None) is not None:
        cargs.extend([
            "-applyisoxfm",
            str(params.get("apply_isoxfm", None))
        ])
    if params.get("apply_xfm", False):
        cargs.append("-applyxfm")
    if params.get("bbrslope", None) is not None:
        cargs.extend([
            "-bbrslope",
            str(params.get("bbrslope", None))
        ])
    if params.get("bbrtype", None) is not None:
        cargs.extend([
            "-bbrtype",
            params.get("bbrtype", None)
        ])
    if params.get("bgvalue", None) is not None:
        cargs.extend([
            "-setbackground",
            str(params.get("bgvalue", None))
        ])
    if params.get("bins", None) is not None:
        cargs.extend([
            "-bins",
            str(params.get("bins", None))
        ])
    if params.get("coarse_search", None) is not None:
        cargs.extend([
            "-coarsesearch",
            str(params.get("coarse_search", None))
        ])
    if params.get("cost", None) is not None:
        cargs.extend([
            "-cost",
            params.get("cost", None)
        ])
    if params.get("cost_func", None) is not None:
        cargs.extend([
            "-searchcost",
            params.get("cost_func", None)
        ])
    if params.get("datatype", None) is not None:
        cargs.extend([
            "-datatype",
            params.get("datatype", None)
        ])
    if params.get("display_init", False):
        cargs.append("-displayinit")
    if params.get("dof", None) is not None:
        cargs.extend([
            "-dof",
            str(params.get("dof", None))
        ])
    if params.get("echospacing", None) is not None:
        cargs.extend([
            "-echospacing",
            str(params.get("echospacing", None))
        ])
    if params.get("fieldmap", None) is not None:
        cargs.extend([
            "-fieldmap",
            execution.input_file(params.get("fieldmap", None))
        ])
    if params.get("fieldmapmask", None) is not None:
        cargs.extend([
            "-fieldmapmask",
            execution.input_file(params.get("fieldmapmask", None))
        ])
    if params.get("fine_search", None) is not None:
        cargs.extend([
            "-finesearch",
            str(params.get("fine_search", None))
        ])
    if params.get("force_scaling", False):
        cargs.append("-forcescaling")
    if params.get("in_matrix_file", None) is not None:
        cargs.extend([
            "-init",
            execution.input_file(params.get("in_matrix_file", None))
        ])
    if params.get("in_weight", None) is not None:
        cargs.extend([
            "-inweight",
            execution.input_file(params.get("in_weight", None))
        ])
    if params.get("interp", None) is not None:
        cargs.extend([
            "-interp",
            params.get("interp", None)
        ])
    if params.get("min_sampling", None) is not None:
        cargs.extend([
            "-minsampling",
            str(params.get("min_sampling", None))
        ])
    if params.get("no_clamp", False):
        cargs.append("-noclamp")
    if params.get("no_resample", False):
        cargs.append("-noresample")
    if params.get("no_resample_blur", False):
        cargs.append("-noresampblur")
    if params.get("no_search", False):
        cargs.append("-nosearch")
    if params.get("padding_size", None) is not None:
        cargs.extend([
            "-paddingsize",
            str(params.get("padding_size", None))
        ])
    if params.get("pedir", None) is not None:
        cargs.extend([
            "-pedir",
            str(params.get("pedir", None))
        ])
    if params.get("ref_weight", None) is not None:
        cargs.extend([
            "-refweight",
            execution.input_file(params.get("ref_weight", None))
        ])
    if params.get("rigid2D", False):
        cargs.append("-2D")
    if params.get("schedule", None) is not None:
        cargs.extend([
            "-schedule",
            execution.input_file(params.get("schedule", None))
        ])
    if params.get("searchr_x", None) is not None:
        cargs.extend([
            "-searchrx",
            *map(str, params.get("searchr_x", None))
        ])
    if params.get("searchr_y", None) is not None:
        cargs.extend([
            "-searchry",
            *map(str, params.get("searchr_y", None))
        ])
    if params.get("searchr_z", None) is not None:
        cargs.extend([
            "-searchrz",
            *map(str, params.get("searchr_z", None))
        ])
    if params.get("sinc_width", None) is not None:
        cargs.extend([
            "-sincwidth",
            str(params.get("sinc_width", None))
        ])
    if params.get("sinc_window", None) is not None:
        cargs.extend([
            "-sincwindow",
            params.get("sinc_window", None)
        ])
    if params.get("uses_qform", False):
        cargs.append("-usesqform")
    if params.get("verbose", None) is not None:
        cargs.extend([
            "-verbose",
            str(params.get("verbose", None))
        ])
    if params.get("wm_seg", None) is not None:
        cargs.extend([
            "-wmseg",
            execution.input_file(params.get("wm_seg", None))
        ])
    if params.get("wmcoords", None) is not None:
        cargs.extend([
            "-wmcoords",
            execution.input_file(params.get("wmcoords", None))
        ])
    if params.get("wmnorms", None) is not None:
        cargs.extend([
            "-wmnorms",
            execution.input_file(params.get("wmnorms", None))
        ])
    return cargs


def flirt_outputs(
    params: FlirtParameters,
    execution: Execution,
) -> FlirtOutputs:
    """
    Build outputs object containing output file paths and possibly stdout/stderr.
    
    Args:
        params: The parameters.
        execution: The execution object for resolving input paths.
    Returns:
        Outputs object.
    """
    ret = FlirtOutputs(
        root=execution.output_file("."),
        out_file=execution.output_file(params.get("out_file", None)),
        out_matrix_file=execution.output_file(params.get("out_matrix_file", None)),
    )
    return ret


def flirt_execute(
    params: FlirtParameters,
    runner: Runner | None = None,
) -> FlirtOutputs:
    """
    flirt
    
    FLIRT (FMRIB's Linear Image Registration Tool) is a fully automated robust
    and accurate tool for linear (affine) intra- and inter-modal brain image
    registration.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        params: The parameters.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FlirtOutputs`).
    """
    runner = runner or get_global_runner()
    execution = runner.start_execution(FLIRT_METADATA)
    params = execution.params(params)
    cargs = flirt_cargs(params, execution)
    ret = flirt_outputs(params, execution)
    execution.run(cargs)
    return ret


def flirt(
    in_file: InputPathType,
    reference: InputPathType,
    out_file: str,
    out_matrix_file: str,
    angle_rep: typing.Literal["quaternion", "euler"] | None = None,
    apply_isoxfm: float | None = None,
    apply_xfm: bool = False,
    bbrslope: float | None = None,
    bbrtype: typing.Literal["signed", "global_abs", "local_abs"] | None = None,
    bgvalue: float | None = None,
    bins: int | None = None,
    coarse_search: int | None = None,
    cost: typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None = None,
    cost_func: typing.Literal["mutualinfo", "corratio", "normcorr", "normmi", "leastsq", "labeldiff", "bbr"] | None = None,
    datatype: typing.Literal["char", "short", "int", "float", "double"] | None = None,
    display_init: bool = False,
    dof: int | None = None,
    echospacing: float | None = None,
    fieldmap: InputPathType | None = None,
    fieldmapmask: InputPathType | None = None,
    fine_search: int | None = None,
    force_scaling: bool = False,
    in_matrix_file: InputPathType | None = None,
    in_weight: InputPathType | None = None,
    interp: typing.Literal["trilinear", "nearestneighbour", "sinc", "spline"] | None = None,
    min_sampling: float | None = None,
    no_clamp: bool = False,
    no_resample: bool = False,
    no_resample_blur: bool = False,
    no_search: bool = False,
    padding_size: int | None = None,
    pedir: int | None = None,
    ref_weight: InputPathType | None = None,
    rigid2_d: bool = False,
    schedule: InputPathType | None = None,
    searchr_x: list[int] | None = None,
    searchr_y: list[int] | None = None,
    searchr_z: list[int] | None = None,
    sinc_width: int | None = None,
    sinc_window: typing.Literal["rectangular", "hanning", "blackman"] | None = None,
    uses_qform: bool = False,
    verbose: int | None = None,
    wm_seg: InputPathType | None = None,
    wmcoords: InputPathType | None = None,
    wmnorms: InputPathType | None = None,
    runner: Runner | None = None,
) -> FlirtOutputs:
    """
    flirt
    
    FLIRT (FMRIB's Linear Image Registration Tool) is a fully automated robust
    and accurate tool for linear (affine) intra- and inter-modal brain image
    registration.
    
    Author: FMRIB Analysis Group, University of Oxford
    
    URL: https://fsl.fmrib.ox.ac.uk/fsl/fslwiki
    
    Args:
        in_file: Input file.
        reference: Reference file.
        out_file: Registered output file.
        out_matrix_file: Output affine matrix in 4x4 asciii format.
        angle_rep: 'quaternion' or 'euler'. Representation of rotation angles.
        apply_isoxfm: As applyxfm but forces isotropic resampling.
        apply_xfm: Apply transformation supplied by in_matrix_file or\
            uses_qform to use the affine matrix stored in the reference header.
        bbrslope: Value of bbr slope.
        bbrtype: 'signed' or 'global_abs' or 'local_abs'. Type of bbr cost\
            function: signed [default], global_abs, local_abs.
        bgvalue: Use specified background value for points outside fov.
        bins: Number of histogram bins.
        coarse_search: Coarse search delta angle.
        cost: 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or 'leastsq'\
            or 'labeldiff' or 'bbr'. Cost function.
        cost_func: 'mutualinfo' or 'corratio' or 'normcorr' or 'normmi' or\
            'leastsq' or 'labeldiff' or 'bbr'. Cost function.
        datatype: 'char' or 'short' or 'int' or 'float' or 'double'. Force\
            output data type.
        display_init: Display initial matrix.
        dof: Number of transform degrees of freedom.
        echospacing: Value of epi echo spacing - units of seconds.
        fieldmap: Fieldmap image in rads/s - must be already registered to the\
            reference image.
        fieldmapmask: Mask for fieldmap image.
        fine_search: Fine search delta angle.
        force_scaling: Force rescaling even for low-res images.
        in_matrix_file: Input 4x4 affine matrix.
        in_weight: File for input weighting volume.
        interp: 'trilinear' or 'nearestneighbour' or 'sinc' or 'spline'. Final\
            interpolation method used in reslicing.
        min_sampling: Set minimum voxel dimension for sampling.
        no_clamp: Do not use intensity clamping.
        no_resample: Do not change input sampling.
        no_resample_blur: Do not use blurring on downsampling.
        no_search: Set all angular searches to ranges 0 to 0.
        padding_size: For applyxfm: interpolates outside image by size.
        pedir: Phase encode direction of epi - 1/2/3=x/y/z & -1/-2/-3=-x/-y/-z.
        ref_weight: File for reference weighting volume.
        rigid2_d: Use 2d rigid body mode - ignores dof.
        schedule: Replaces default schedule.
        searchr_x: Search angles along x-axis, in degrees.
        searchr_y: Search angles along y-axis, in degrees.
        searchr_z: Search angles along z-axis, in degrees.
        sinc_width: Full-width in voxels.
        sinc_window: 'rectangular' or 'hanning' or 'blackman'. Sinc window.
        uses_qform: Initialize using sform or qform.
        verbose: Verbose mode, 0 is least.
        wm_seg: White matter segmentation volume needed by bbr cost function.
        wmcoords: White matter boundary coordinates for bbr cost function.
        wmnorms: White matter boundary normals for bbr cost function.
        runner: Command runner.
    Returns:
        NamedTuple of outputs (described in `FlirtOutputs`).
    """
    params = flirt_params(
        in_file=in_file,
        reference=reference,
        out_file=out_file,
        out_matrix_file=out_matrix_file,
        angle_rep=angle_rep,
        apply_isoxfm=apply_isoxfm,
        apply_xfm=apply_xfm,
        bbrslope=bbrslope,
        bbrtype=bbrtype,
        bgvalue=bgvalue,
        bins=bins,
        coarse_search=coarse_search,
        cost=cost,
        cost_func=cost_func,
        datatype=datatype,
        display_init=display_init,
        dof=dof,
        echospacing=echospacing,
        fieldmap=fieldmap,
        fieldmapmask=fieldmapmask,
        fine_search=fine_search,
        force_scaling=force_scaling,
        in_matrix_file=in_matrix_file,
        in_weight=in_weight,
        interp=interp,
        min_sampling=min_sampling,
        no_clamp=no_clamp,
        no_resample=no_resample,
        no_resample_blur=no_resample_blur,
        no_search=no_search,
        padding_size=padding_size,
        pedir=pedir,
        ref_weight=ref_weight,
        rigid2_d=rigid2_d,
        schedule=schedule,
        searchr_x=searchr_x,
        searchr_y=searchr_y,
        searchr_z=searchr_z,
        sinc_width=sinc_width,
        sinc_window=sinc_window,
        uses_qform=uses_qform,
        verbose=verbose,
        wm_seg=wm_seg,
        wmcoords=wmcoords,
        wmnorms=wmnorms,
    )
    return flirt_execute(params, runner)


__all__ = [
    "FLIRT_METADATA",
    "FlirtOutputs",
    "flirt",
    "flirt_execute",
    "flirt_params",
]
